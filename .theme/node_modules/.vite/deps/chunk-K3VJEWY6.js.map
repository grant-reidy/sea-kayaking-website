{
  "version": 3,
  "sources": ["../../lit-html/src/directive.ts", "../../lit-html/src/directive-helpers.ts", "../../lit-html/src/experimental-hydrate.ts", "../../lit-element/src/experimental-hydrate-support.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Disconnectable, Part} from './lit-html.js';\n\nexport {\n  AttributePart,\n  BooleanAttributePart,\n  ChildPart,\n  ElementPart,\n  EventPart,\n  Part,\n  PropertyPart,\n} from './lit-html.js';\n\nexport interface DirectiveClass {\n  new (part: PartInfo): Directive;\n}\n\n/**\n * This utility type extracts the signature of a directive class's render()\n * method so we can use it for the type of the generated directive function.\n */\nexport type DirectiveParameters<C extends Directive> = Parameters<C['render']>;\n\n/**\n * A generated directive function doesn't evaluate the directive, but just\n * returns a DirectiveResult object that captures the arguments.\n */\nexport interface DirectiveResult<C extends DirectiveClass = DirectiveClass> {\n  /**\n   * This property needs to remain unminified.\n   * @internal */\n  ['_$litDirective$']: C;\n  /** @internal */\n  values: DirectiveParameters<InstanceType<C>>;\n}\n\nexport const PartType = {\n  ATTRIBUTE: 1,\n  CHILD: 2,\n  PROPERTY: 3,\n  BOOLEAN_ATTRIBUTE: 4,\n  EVENT: 5,\n  ELEMENT: 6,\n} as const;\n\nexport type PartType = typeof PartType[keyof typeof PartType];\n\nexport interface ChildPartInfo {\n  readonly type: typeof PartType.CHILD;\n}\n\nexport interface AttributePartInfo {\n  readonly type:\n    | typeof PartType.ATTRIBUTE\n    | typeof PartType.PROPERTY\n    | typeof PartType.BOOLEAN_ATTRIBUTE\n    | typeof PartType.EVENT;\n  readonly strings?: ReadonlyArray<string>;\n  readonly name: string;\n  readonly tagName: string;\n}\n\nexport interface ElementPartInfo {\n  readonly type: typeof PartType.ELEMENT;\n}\n\n/**\n * Information about the part a directive is bound to.\n *\n * This is useful for checking that a directive is attached to a valid part,\n * such as with directive that can only be used on attribute bindings.\n */\nexport type PartInfo = ChildPartInfo | AttributePartInfo | ElementPartInfo;\n\n/**\n * Creates a user-facing directive function from a Directive class. This\n * function has the same parameters as the directive's render() method.\n */\nexport const directive =\n  <C extends DirectiveClass>(c: C) =>\n  (...values: DirectiveParameters<InstanceType<C>>): DirectiveResult<C> => ({\n    // This property needs to remain unminified.\n    ['_$litDirective$']: c,\n    values,\n  });\n\n/**\n * Base class for creating custom directives. Users should extend this class,\n * implement `render` and/or `update`, and then pass their subclass to\n * `directive`.\n */\nexport abstract class Directive implements Disconnectable {\n  //@internal\n  __part!: Part;\n  //@internal\n  __attributeIndex: number | undefined;\n  //@internal\n  __directive?: Directive;\n\n  //@internal\n  _$parent!: Disconnectable;\n\n  // These will only exist on the AsyncDirective subclass\n  //@internal\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // This property needs to remain unminified.\n  //@internal\n  ['_$notifyDirectiveConnectionChanged']?(isConnected: boolean): void;\n\n  constructor(_partInfo: PartInfo) {}\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  /** @internal */\n  _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    this.__part = part;\n    this._$parent = parent;\n    this.__attributeIndex = attributeIndex;\n  }\n  /** @internal */\n  _$resolve(part: Part, props: Array<unknown>): unknown {\n    return this.update(part, props);\n  }\n\n  abstract render(...props: Array<unknown>): unknown;\n\n  update(_part: Part, props: Array<unknown>): unknown {\n    return this.render(...props);\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {_$LH, Part, DirectiveParent, TemplateResult} from './lit-html.js';\nimport {\n  DirectiveResult,\n  DirectiveClass,\n  PartInfo,\n  AttributePartInfo,\n} from './directive.js';\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\n\nconst {_ChildPart: ChildPart} = _$LH;\n\ntype ChildPart = InstanceType<typeof ChildPart>;\n\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\n/**\n * Tests if a value is a primitive value.\n *\n * See https://tc39.github.io/ecma262/#sec-typeof-operator\n */\nexport const isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\n\nexport const TemplateResultType = {\n  HTML: 1,\n  SVG: 2,\n} as const;\n\nexport type TemplateResultType =\n  typeof TemplateResultType[keyof typeof TemplateResultType];\n\n/**\n * Tests if a value is a TemplateResult.\n */\nexport const isTemplateResult = (\n  value: unknown,\n  type?: TemplateResultType\n): value is TemplateResult =>\n  type === undefined\n    ? // This property needs to remain unminified.\n      (value as TemplateResult)?.['_$litType$'] !== undefined\n    : (value as TemplateResult)?.['_$litType$'] === type;\n\n/**\n * Tests if a value is a DirectiveResult.\n */\nexport const isDirectiveResult = (value: unknown): value is DirectiveResult =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'] !== undefined;\n\n/**\n * Retrieves the Directive class for a DirectiveResult\n */\nexport const getDirectiveClass = (value: unknown): DirectiveClass | undefined =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'];\n\n/**\n * Tests whether a part has only a single-expression with no strings to\n * interpolate between.\n *\n * Only AttributePart and PropertyPart can have multiple expressions.\n * Multi-expression parts have a `strings` property and single-expression\n * parts do not.\n */\nexport const isSingleExpression = (part: PartInfo) =>\n  (part as AttributePartInfo).strings === undefined;\n\nconst createMarker = () => document.createComment('');\n\n/**\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\n * end of the container ChildPart, or before the optional `refPart`.\n *\n * This does not add the part to the containerPart's committed value. That must\n * be done by callers.\n *\n * @param containerPart Part within which to add the new ChildPart\n * @param refPart Part before which to add the new ChildPart; when omitted the\n *     part added to the end of the `containerPart`\n * @param part Part to insert, or undefined to create a new part\n */\nexport const insertPart = (\n  containerPart: ChildPart,\n  refPart?: ChildPart,\n  part?: ChildPart\n): ChildPart => {\n  const container = wrap(containerPart._$startNode).parentNode!;\n\n  const refNode =\n    refPart === undefined ? containerPart._$endNode : refPart._$startNode;\n\n  if (part === undefined) {\n    const startNode = wrap(container).insertBefore(createMarker(), refNode);\n    const endNode = wrap(container).insertBefore(createMarker(), refNode);\n    part = new ChildPart(\n      startNode,\n      endNode,\n      containerPart,\n      containerPart.options\n    );\n  } else {\n    const endNode = wrap(part._$endNode!).nextSibling;\n    const oldParent = part._$parent;\n    const parentChanged = oldParent !== containerPart;\n    if (parentChanged) {\n      part._$reparentDisconnectables?.(containerPart);\n      // Note that although `_$reparentDisconnectables` updates the part's\n      // `_$parent` reference after unlinking from its current parent, that\n      // method only exists if Disconnectables are present, so we need to\n      // unconditionally set it here\n      part._$parent = containerPart;\n      // Since the _$isConnected getter is somewhat costly, only\n      // read it once we know the subtree has directives that need\n      // to be notified\n      let newConnectionState;\n      if (\n        part._$notifyConnectionChanged !== undefined &&\n        (newConnectionState = containerPart._$isConnected) !==\n          oldParent!._$isConnected\n      ) {\n        part._$notifyConnectionChanged(newConnectionState);\n      }\n    }\n    if (endNode !== refNode || parentChanged) {\n      let start: Node | null = part._$startNode;\n      while (start !== endNode) {\n        const n: Node | null = wrap(start!).nextSibling;\n        wrap(container).insertBefore(start!, refNode);\n        start = n;\n      }\n    }\n  }\n\n  return part;\n};\n\n/**\n * Sets the value of a Part.\n *\n * Note that this should only be used to set/update the value of user-created\n * parts (i.e. those created using `insertPart`); it should not be used\n * by directives to set the value of the directive's container part. Directives\n * should return a value from `update`/`render` to update their part state.\n *\n * For directives that require setting their part value asynchronously, they\n * should extend `AsyncDirective` and call `this.setValue()`.\n *\n * @param part Part to set\n * @param value Value to set\n * @param index For `AttributePart`s, the index to set\n * @param directiveParent Used internally; should not be set by user\n */\nexport const setChildPartValue = <T extends ChildPart>(\n  part: T,\n  value: unknown,\n  directiveParent: DirectiveParent = part\n): T => {\n  part._$setValue(value, directiveParent);\n  return part;\n};\n\n// A sentinal value that can never appear as a part value except when set by\n// live(). Used to force a dirty-check to fail and cause a re-render.\nconst RESET_VALUE = {};\n\n/**\n * Sets the committed value of a ChildPart directly without triggering the\n * commit stage of the part.\n *\n * This is useful in cases where a directive needs to update the part such\n * that the next update detects a value change or not. When value is omitted,\n * the next update will be guaranteed to be detected as a change.\n *\n * @param part\n * @param value\n */\nexport const setCommittedValue = (part: Part, value: unknown = RESET_VALUE) =>\n  (part._$committedValue = value);\n\n/**\n * Returns the committed value of a ChildPart.\n *\n * The committed value is used for change detection and efficient updates of\n * the part. It can differ from the value set by the template or directive in\n * cases where the template value is transformed before being commited.\n *\n * - `TemplateResult`s are committed as a `TemplateInstance`\n * - Iterables are committed as `Array<ChildPart>`\n * - All other types are committed as the template value or value returned or\n *   set by a directive.\n *\n * @param part\n */\nexport const getCommittedValue = (part: ChildPart) => part._$committedValue;\n\n/**\n * Removes a ChildPart from the DOM, including any of its content.\n *\n * @param part The Part to remove\n */\nexport const removePart = (part: ChildPart) => {\n  part._$notifyConnectionChanged?.(false, true);\n  let start: ChildNode | null = part._$startNode;\n  const end: ChildNode | null = wrap(part._$endNode!).nextSibling;\n  while (start !== end) {\n    const n: ChildNode | null = wrap(start!).nextSibling;\n    (wrap(start!) as ChildNode).remove();\n    start = n;\n  }\n};\n\nexport const clearPart = (part: ChildPart) => {\n  part._$clear();\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {TemplateResult} from './lit-html.js';\n\nimport {noChange, RenderOptions, _$LH} from './lit-html.js';\nimport {AttributePartInfo, PartType} from './directive.js';\nimport {\n  isPrimitive,\n  isSingleExpression,\n  isTemplateResult,\n} from './directive-helpers.js';\n\nconst {\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  _ChildPart: ChildPart,\n  _ElementPart: ElementPart,\n} = _$LH;\n\ntype ChildPart = InstanceType<typeof ChildPart>;\ntype TemplateInstance = InstanceType<typeof TemplateInstance>;\n\n/**\n * Information needed to rehydrate a single TemplateResult.\n */\ntype ChildPartState =\n  | {\n      type: 'leaf';\n      /** The ChildPart that the result is rendered to */\n      part: ChildPart;\n    }\n  | {\n      type: 'iterable';\n      /** The ChildPart that the result is rendered to */\n      part: ChildPart;\n      value: Iterable<unknown>;\n      iterator: Iterator<unknown>;\n      done: boolean;\n    }\n  | {\n      type: 'template-instance';\n      /** The ChildPart that the result is rendered to */\n      part: ChildPart;\n\n      result: TemplateResult;\n\n      /** The TemplateInstance created from the TemplateResult */\n      instance: TemplateInstance;\n\n      /**\n       * The index of the next Template part to be hydrated. This is mutable and\n       * updated as the tree walk discovers new part markers at the right level in\n       * the template instance tree.  Note there is only one Template part per\n       * attribute with (one or more) bindings.\n       */\n      templatePartIndex: number;\n\n      /**\n       * The index of the next TemplateInstance part to be hydrated. This is used\n       * to retrieve the value from the TemplateResult and initialize the\n       * TemplateInstance parts' values for dirty-checking on first render.\n       */\n      instancePartIndex: number;\n    };\n\n/**\n * hydrate() operates on a container with server-side rendered content and\n * restores the client side data structures needed for lit-html updates such as\n * TemplateInstances and Parts. After calling `hydrate`, lit-html will behave as\n * if it initially rendered the DOM, and any subsequent updates will update\n * efficiently, the same as if lit-html had rendered the DOM on the client.\n *\n * hydrate() must be called on DOM that adheres the to lit-ssr structure for\n * parts. ChildParts must be represented with both a start and end comment\n * marker, and ChildParts that contain a TemplateInstance must have the template\n * digest written into the comment data.\n *\n * Since render() encloses its output in a ChildPart, there must always be a root\n * ChildPart.\n *\n * Example (using for # ... for annotations in HTML)\n *\n * Given this input:\n *\n *   html`<div class=${x}>${y}</div>`\n *\n * The SSR DOM is:\n *\n *   <!--lit-part AEmR7W+R0Ak=-->  # Start marker for the root ChildPart created\n *                                 # by render(). Includes the digest of the\n *                                 # template\n *   <div class=\"TEST_X\">\n *     <!--lit-node 0--> # Indicates there are attribute bindings here\n *                           # The number is the depth-first index of the parent\n *                           # node in the template.\n *     <!--lit-part-->  # Start marker for the ${x} expression\n *     TEST_Y\n *     <!--/lit-part-->  # End marker for the ${x} expression\n *   </div>\n *\n *   <!--/lit-part-->  # End marker for the root ChildPart\n *\n * @param rootValue\n * @param container\n * @param userOptions\n */\nexport const hydrate = (\n  rootValue: unknown,\n  container: Element | DocumentFragment,\n  options: Partial<RenderOptions> = {}\n) => {\n  // TODO(kschaaf): Do we need a helper for _$litPart$ (\"part for node\")?\n  // This property needs to remain unminified.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((container as any)['_$litPart$'] !== undefined) {\n    throw new Error('container already contains a live render');\n  }\n\n  // Since render() creates a ChildPart to render into, we'll always have\n  // exactly one root part. We need to hold a reference to it so we can set\n  // it in the parts cache.\n  let rootPart: ChildPart | undefined = undefined;\n\n  // When we are in-between ChildPart markers, this is the current ChildPart.\n  // It's needed to be able to set the ChildPart's endNode when we see a\n  // close marker\n  let currentChildPart: ChildPart | undefined = undefined;\n\n  // Used to remember parent template state as we recurse into nested\n  // templates\n  const stack: Array<ChildPartState> = [];\n\n  const walker = document.createTreeWalker(\n    container,\n    NodeFilter.SHOW_COMMENT,\n    null,\n    false\n  );\n  let marker: Comment | null;\n\n  // Walk the DOM looking for part marker comments\n  while ((marker = walker.nextNode() as Comment | null) !== null) {\n    const markerText = marker.data;\n    if (markerText.startsWith('lit-part')) {\n      if (stack.length === 0 && rootPart !== undefined) {\n        throw new Error('there must be only one root part per container');\n      }\n      // Create a new ChildPart and push it onto the stack\n      currentChildPart = openChildPart(rootValue, marker, stack, options);\n      rootPart ??= currentChildPart;\n    } else if (markerText.startsWith('lit-node')) {\n      // Create and hydrate attribute parts into the current ChildPart on the\n      // stack\n      createAttributeParts(marker, stack, options);\n    } else if (markerText.startsWith('/lit-part')) {\n      // Close the current ChildPart, and pop the previous one off the stack\n      if (stack.length === 1 && currentChildPart !== rootPart) {\n        throw new Error('internal error');\n      }\n      currentChildPart = closeChildPart(marker, currentChildPart, stack);\n    }\n  }\n  console.assert(\n    rootPart !== undefined,\n    'there should be exactly one root part in a render container'\n  );\n  // This property needs to remain unminified.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (container as any)['_$litPart$'] = rootPart;\n};\n\nconst openChildPart = (\n  rootValue: unknown,\n  marker: Comment,\n  stack: Array<ChildPartState>,\n  options: RenderOptions\n) => {\n  let value: unknown;\n  // We know the startNode now. We'll know the endNode when we get to\n  // the matching marker and set it in closeChildPart()\n  // TODO(kschaaf): Current constructor takes both nodes\n  let part;\n  if (stack.length === 0) {\n    part = new ChildPart(marker, null, undefined, options);\n    value = rootValue;\n  } else {\n    const state = stack[stack.length - 1];\n    if (state.type === 'template-instance') {\n      part = new ChildPart(marker, null, state.instance, options);\n      state.instance._parts.push(part);\n      value = state.result.values[state.instancePartIndex++];\n      state.templatePartIndex++;\n    } else if (state.type === 'iterable') {\n      part = new ChildPart(marker, null, state.part, options);\n      const result = state.iterator.next();\n      if (result.done) {\n        value = undefined;\n        state.done = true;\n        throw new Error('Unhandled shorter than expected iterable');\n      } else {\n        value = result.value;\n      }\n      (state.part._$committedValue as Array<ChildPart>).push(part);\n    } else {\n      // state.type === 'leaf'\n      // TODO(kschaaf): This is unexpected, and likely a result of a primitive\n      // been rendered on the client when a TemplateResult was rendered on the\n      // server; this part will be hydrated but not used. We can detect it, but\n      // we need to decide what to do in this case. Note that this part won't be\n      // retained by any parent TemplateInstance, since a primitive had been\n      // rendered in its place.\n      // https://github.com/lit/lit/issues/1434\n      // throw new Error('Hydration value mismatch: Found a TemplateInstance' +\n      //  'where a leaf value was expected');\n      part = new ChildPart(marker, null, state.part, options);\n    }\n  }\n\n  // Initialize the ChildPart state depending on the type of value and push\n  // it onto the stack. This logic closely follows the ChildPart commit()\n  // cascade order:\n  // 1. directive\n  // 2. noChange\n  // 3. primitive (note strings must be handled before iterables, since they\n  //    are iterable)\n  // 4. TemplateResult\n  // 5. Node (not yet implemented, but fallback handling is fine)\n  // 6. Iterable\n  // 7. nothing (handled in fallback)\n  // 8. Fallback for everything else\n  value = resolveDirective(part, value);\n  if (value === noChange) {\n    stack.push({part, type: 'leaf'});\n  } else if (isPrimitive(value)) {\n    stack.push({part, type: 'leaf'});\n    part._$committedValue = value;\n    // TODO(kschaaf): We can detect when a primitive is being hydrated on the\n    // client where a TemplateResult was rendered on the server, but we need to\n    // decide on a strategy for what to do next.\n    // https://github.com/lit/lit/issues/1434\n    // if (marker.data !== 'lit-part') {\n    //   throw new Error('Hydration value mismatch: Primitive found where TemplateResult expected');\n    // }\n  } else if (isTemplateResult(value)) {\n    // Check for a template result digest\n    const markerWithDigest = `lit-part ${digestForTemplateResult(value)}`;\n    if (marker.data === markerWithDigest) {\n      const template = ChildPart.prototype._$getTemplate(value);\n      const instance = new TemplateInstance(template, part);\n      stack.push({\n        type: 'template-instance',\n        instance,\n        part,\n        templatePartIndex: 0,\n        instancePartIndex: 0,\n        result: value,\n      });\n      // For TemplateResult values, we set the part value to the\n      // generated TemplateInstance\n      part._$committedValue = instance;\n    } else {\n      // TODO: if this isn't the server-rendered template, do we\n      // need to stop hydrating this subtree? Clear it? Add tests.\n      throw new Error(\n        'Hydration value mismatch: Unexpected TemplateResult rendered to part'\n      );\n    }\n  } else if (isIterable(value)) {\n    // currentChildPart.value will contain an array of ChildParts\n    stack.push({\n      part: part,\n      type: 'iterable',\n      value,\n      iterator: value[Symbol.iterator](),\n      done: false,\n    });\n    part._$committedValue = [];\n  } else {\n    // Fallback for everything else (nothing, Objects, Functions,\n    // etc.): we just initialize the part's value\n    // Note that `Node` value types are not currently supported during\n    // SSR, so that part of the cascade is missing.\n    stack.push({part: part, type: 'leaf'});\n    part._$committedValue = value == null ? '' : value;\n  }\n  return part;\n};\n\nconst closeChildPart = (\n  marker: Comment,\n  part: ChildPart | undefined,\n  stack: Array<ChildPartState>\n): ChildPart | undefined => {\n  if (part === undefined) {\n    throw new Error('unbalanced part marker');\n  }\n\n  part._$endNode = marker;\n\n  const currentState = stack.pop()!;\n\n  if (currentState.type === 'iterable') {\n    if (!currentState.iterator.next().done) {\n      throw new Error('unexpected longer than expected iterable');\n    }\n  }\n\n  if (stack.length > 0) {\n    const state = stack[stack.length - 1];\n    return state.part;\n  } else {\n    return undefined;\n  }\n};\n\nconst createAttributeParts = (\n  comment: Comment,\n  stack: Array<ChildPartState>,\n  options: RenderOptions\n) => {\n  // Get the nodeIndex from DOM. We're only using this for an integrity\n  // check right now, we might not need it.\n  const match = /lit-node (\\d+)/.exec(comment.data)!;\n  const nodeIndex = parseInt(match[1]);\n\n  // For void elements, the node the comment was referring to will be\n  // the previousSibling; for non-void elements, the comment is guaranteed\n  // to be the first child of the element (i.e. it won't have a previousSibling\n  // meaning it should use the parentElement)\n  const node = comment.previousElementSibling ?? comment.parentElement;\n  if (node === null) {\n    throw new Error('could not find node for attribute parts');\n  }\n  // Remove `defer-hydration` attribute, if any\n  node.removeAttribute('defer-hydration');\n\n  const state = stack[stack.length - 1];\n  if (state.type === 'template-instance') {\n    const instance = state.instance;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // If the next template part is in attribute-position on the current node,\n      // create the instance part for it and prime its state\n      const templatePart = instance._$template.parts[state.templatePartIndex];\n      if (\n        templatePart === undefined ||\n        (templatePart.type !== PartType.ATTRIBUTE &&\n          templatePart.type !== PartType.ELEMENT) ||\n        templatePart.index !== nodeIndex\n      ) {\n        break;\n      }\n\n      if (templatePart.type === PartType.ATTRIBUTE) {\n        // The instance part is created based on the constructor saved in the\n        // template part\n        const instancePart = new templatePart.ctor(\n          node as HTMLElement,\n          templatePart.name,\n          templatePart.strings,\n          state.instance,\n          options\n        );\n\n        const value = isSingleExpression(\n          instancePart as unknown as AttributePartInfo\n        )\n          ? state.result.values[state.instancePartIndex]\n          : state.result.values;\n\n        // Setting the attribute value primes committed value with the resolved\n        // directive value; we only then commit that value for event/property\n        // parts since those were not serialized, and pass `noCommit` for the\n        // others to avoid perf impact of touching the DOM unnecessarily\n        const noCommit = !(\n          instancePart.type === PartType.EVENT ||\n          instancePart.type === PartType.PROPERTY\n        );\n        instancePart._$setValue(\n          value,\n          instancePart,\n          state.instancePartIndex,\n          noCommit\n        );\n        state.instancePartIndex += templatePart.strings.length - 1;\n        instance._parts.push(instancePart);\n      } else {\n        // templatePart.type === PartType.ELEMENT\n        const instancePart = new ElementPart(node, state.instance, options);\n        resolveDirective(\n          instancePart,\n          state.result.values[state.instancePartIndex++]\n        );\n        instance._parts.push(instancePart);\n      }\n      state.templatePartIndex++;\n    }\n  } else {\n    throw new Error('internal error');\n  }\n};\n\n// Number of 32 bit elements to use to create template digests\nconst digestSize = 2;\n// We need to specify a digest to use across rendering environments. This is a\n// simple digest build from a DJB2-ish hash modified from:\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\n// It has been changed to an array of hashes to add additional bits.\n// Goals:\n//  - Extremely low collision rate. We may not be able to detect collisions.\n//  - Extremely fast.\n//  - Extremely small code size.\n//  - Safe to include in HTML comment text or attribute value.\n//  - Easily specifiable and implementable in multiple languages.\n// We don't care about cryptographic suitability.\nexport const digestForTemplateResult = (templateResult: TemplateResult) => {\n  const hashes = new Uint32Array(digestSize).fill(5381);\n\n  for (const s of templateResult.strings) {\n    for (let i = 0; i < s.length; i++) {\n      hashes[i % digestSize] = (hashes[i % digestSize] * 33) ^ s.charCodeAt(i);\n    }\n  }\n  return btoa(String.fromCharCode(...new Uint8Array(hashes.buffer)));\n};\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * LitElement support for hydration of content rendered using lit-ssr.\n *\n * @packageDocumentation\n */\n\nimport type {PropertyValues} from '@lit/reactive-element';\nimport {render, RenderOptions} from 'lit-html';\nimport {hydrate} from 'lit-html/experimental-hydrate.js';\n\ninterface PatchableLitElement extends HTMLElement {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableLitElement;\n  enableUpdating(requestedUpdate?: boolean): void;\n  createRenderRoot(): Element | ShadowRoot;\n  renderRoot: HTMLElement | DocumentFragment;\n  render(): unknown;\n  renderOptions: RenderOptions;\n  _$needsHydration: boolean;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nglobalThis.litElementHydrateSupport = ({\n  LitElement,\n}: {\n  LitElement: PatchableLitElement;\n}) => {\n  const observedAttributes = Object.getOwnPropertyDescriptor(\n    Object.getPrototypeOf(LitElement),\n    'observedAttributes'\n  )!.get!;\n\n  // Add `defer-hydration` to observedAttributes\n  Object.defineProperty(LitElement, 'observedAttributes', {\n    get() {\n      return [...observedAttributes.call(this), 'defer-hydration'];\n    },\n  });\n\n  // Enable element when 'defer-hydration' attribute is removed by calling the\n  // super.connectedCallback()\n  const attributeChangedCallback =\n    LitElement.prototype.attributeChangedCallback;\n  LitElement.prototype.attributeChangedCallback = function (\n    name: string,\n    old: string | null,\n    value: string | null\n  ) {\n    if (name === 'defer-hydration' && value === null) {\n      connectedCallback.call(this);\n    }\n    attributeChangedCallback.call(this, name, old, value);\n  };\n\n  // Override `connectedCallback` to capture whether we need hydration, and\n  // defer `super.connectedCallback()` if the 'defer-hydration' attribute is set\n  const connectedCallback = LitElement.prototype.connectedCallback;\n  LitElement.prototype.connectedCallback = function (\n    this: PatchableLitElement\n  ) {\n    // If the outer scope of this element has not yet been hydrated, wait until\n    // 'defer-hydration' attribute has been removed to enable\n    if (!this.hasAttribute('defer-hydration')) {\n      connectedCallback.call(this);\n    }\n  };\n\n  // If we've been server-side rendered, just return `this.shadowRoot`, don't\n  // call the base implementation, which would also adopt styles (for now)\n  const createRenderRoot = LitElement.prototype.createRenderRoot;\n  LitElement.prototype.createRenderRoot = function (this: PatchableLitElement) {\n    if (this.shadowRoot) {\n      this._$needsHydration = true;\n      return this.shadowRoot;\n    } else {\n      return createRenderRoot.call(this);\n    }\n  };\n\n  // Hydrate on first update when needed\n  const update = Object.getPrototypeOf(LitElement.prototype).update;\n  LitElement.prototype.update = function (\n    this: PatchableLitElement,\n    changedProperties: PropertyValues\n  ) {\n    const value = this.render();\n    // Since this is a patch, we can't call super.update(), so we capture\n    // it off the proto chain and call it instead\n    update.call(this, changedProperties);\n    if (this._$needsHydration) {\n      this._$needsHydration = false;\n      hydrate(value, this.renderRoot, this.renderOptions);\n    } else {\n      render(value, this.renderRoot, this.renderOptions);\n    }\n  };\n};\n"],
  "mappings": "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",
  "names": ["ChildPart", "_a"]
}
