import {
  _$LH,
  noChange,
  render
} from "./chunk-KSQ7TIKS.js";

// node_modules/lit-html/development/directive.js
var PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};

// node_modules/lit-html/development/directive-helpers.js
var _a;
var _b;
var { _ChildPart: ChildPart } = _$LH;
var ENABLE_SHADYDOM_NOPATCH = true;
var wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) && ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
var isPrimitive = (value) => value === null || typeof value != "object" && typeof value != "function";
var isTemplateResult = (value, type) => type === void 0 ? (value === null || value === void 0 ? void 0 : value["_$litType$"]) !== void 0 : (value === null || value === void 0 ? void 0 : value["_$litType$"]) === type;
var isSingleExpression = (part) => part.strings === void 0;

// node_modules/lit-html/development/experimental-hydrate.js
var { _TemplateInstance: TemplateInstance, _isIterable: isIterable, _resolveDirective: resolveDirective, _ChildPart: ChildPart2, _ElementPart: ElementPart } = _$LH;
var hydrate = (rootValue, container, options = {}) => {
  if (container["_$litPart$"] !== void 0) {
    throw new Error("container already contains a live render");
  }
  let rootPart = void 0;
  let currentChildPart = void 0;
  const stack = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_COMMENT, null, false);
  let marker;
  while ((marker = walker.nextNode()) !== null) {
    const markerText = marker.data;
    if (markerText.startsWith("lit-part")) {
      if (stack.length === 0 && rootPart !== void 0) {
        throw new Error("there must be only one root part per container");
      }
      currentChildPart = openChildPart(rootValue, marker, stack, options);
      rootPart !== null && rootPart !== void 0 ? rootPart : rootPart = currentChildPart;
    } else if (markerText.startsWith("lit-node")) {
      createAttributeParts(marker, stack, options);
    } else if (markerText.startsWith("/lit-part")) {
      if (stack.length === 1 && currentChildPart !== rootPart) {
        throw new Error("internal error");
      }
      currentChildPart = closeChildPart(marker, currentChildPart, stack);
    }
  }
  console.assert(rootPart !== void 0, "there should be exactly one root part in a render container");
  container["_$litPart$"] = rootPart;
};
var openChildPart = (rootValue, marker, stack, options) => {
  let value;
  let part;
  if (stack.length === 0) {
    part = new ChildPart2(marker, null, void 0, options);
    value = rootValue;
  } else {
    const state = stack[stack.length - 1];
    if (state.type === "template-instance") {
      part = new ChildPart2(marker, null, state.instance, options);
      state.instance._parts.push(part);
      value = state.result.values[state.instancePartIndex++];
      state.templatePartIndex++;
    } else if (state.type === "iterable") {
      part = new ChildPart2(marker, null, state.part, options);
      const result = state.iterator.next();
      if (result.done) {
        value = void 0;
        state.done = true;
        throw new Error("Unhandled shorter than expected iterable");
      } else {
        value = result.value;
      }
      state.part._$committedValue.push(part);
    } else {
      part = new ChildPart2(marker, null, state.part, options);
    }
  }
  value = resolveDirective(part, value);
  if (value === noChange) {
    stack.push({ part, type: "leaf" });
  } else if (isPrimitive(value)) {
    stack.push({ part, type: "leaf" });
    part._$committedValue = value;
  } else if (isTemplateResult(value)) {
    const markerWithDigest = `lit-part ${digestForTemplateResult(value)}`;
    if (marker.data === markerWithDigest) {
      const template = ChildPart2.prototype._$getTemplate(value);
      const instance = new TemplateInstance(template, part);
      stack.push({
        type: "template-instance",
        instance,
        part,
        templatePartIndex: 0,
        instancePartIndex: 0,
        result: value
      });
      part._$committedValue = instance;
    } else {
      throw new Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");
    }
  } else if (isIterable(value)) {
    stack.push({
      part,
      type: "iterable",
      value,
      iterator: value[Symbol.iterator](),
      done: false
    });
    part._$committedValue = [];
  } else {
    stack.push({ part, type: "leaf" });
    part._$committedValue = value == null ? "" : value;
  }
  return part;
};
var closeChildPart = (marker, part, stack) => {
  if (part === void 0) {
    throw new Error("unbalanced part marker");
  }
  part._$endNode = marker;
  const currentState = stack.pop();
  if (currentState.type === "iterable") {
    if (!currentState.iterator.next().done) {
      throw new Error("unexpected longer than expected iterable");
    }
  }
  if (stack.length > 0) {
    const state = stack[stack.length - 1];
    return state.part;
  } else {
    return void 0;
  }
};
var createAttributeParts = (comment, stack, options) => {
  var _a2;
  const match = /lit-node (\d+)/.exec(comment.data);
  const nodeIndex = parseInt(match[1]);
  const node = (_a2 = comment.previousElementSibling) !== null && _a2 !== void 0 ? _a2 : comment.parentElement;
  if (node === null) {
    throw new Error("could not find node for attribute parts");
  }
  node.removeAttribute("defer-hydration");
  const state = stack[stack.length - 1];
  if (state.type === "template-instance") {
    const instance = state.instance;
    while (true) {
      const templatePart = instance._$template.parts[state.templatePartIndex];
      if (templatePart === void 0 || templatePart.type !== PartType.ATTRIBUTE && templatePart.type !== PartType.ELEMENT || templatePart.index !== nodeIndex) {
        break;
      }
      if (templatePart.type === PartType.ATTRIBUTE) {
        const instancePart = new templatePart.ctor(node, templatePart.name, templatePart.strings, state.instance, options);
        const value = isSingleExpression(instancePart) ? state.result.values[state.instancePartIndex] : state.result.values;
        const noCommit = !(instancePart.type === PartType.EVENT || instancePart.type === PartType.PROPERTY);
        instancePart._$setValue(value, instancePart, state.instancePartIndex, noCommit);
        state.instancePartIndex += templatePart.strings.length - 1;
        instance._parts.push(instancePart);
      } else {
        const instancePart = new ElementPart(node, state.instance, options);
        resolveDirective(instancePart, state.result.values[state.instancePartIndex++]);
        instance._parts.push(instancePart);
      }
      state.templatePartIndex++;
    }
  } else {
    throw new Error("internal error");
  }
};
var digestSize = 2;
var digestForTemplateResult = (templateResult) => {
  const hashes = new Uint32Array(digestSize).fill(5381);
  for (const s of templateResult.strings) {
    for (let i = 0; i < s.length; i++) {
      hashes[i % digestSize] = hashes[i % digestSize] * 33 ^ s.charCodeAt(i);
    }
  }
  return btoa(String.fromCharCode(...new Uint8Array(hashes.buffer)));
};

// node_modules/lit-element/development/experimental-hydrate-support.js
globalThis.litElementHydrateSupport = ({ LitElement }) => {
  const observedAttributes = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(LitElement), "observedAttributes").get;
  Object.defineProperty(LitElement, "observedAttributes", {
    get() {
      return [...observedAttributes.call(this), "defer-hydration"];
    }
  });
  const attributeChangedCallback = LitElement.prototype.attributeChangedCallback;
  LitElement.prototype.attributeChangedCallback = function(name, old, value) {
    if (name === "defer-hydration" && value === null) {
      connectedCallback.call(this);
    }
    attributeChangedCallback.call(this, name, old, value);
  };
  const connectedCallback = LitElement.prototype.connectedCallback;
  LitElement.prototype.connectedCallback = function() {
    if (!this.hasAttribute("defer-hydration")) {
      connectedCallback.call(this);
    }
  };
  const createRenderRoot = LitElement.prototype.createRenderRoot;
  LitElement.prototype.createRenderRoot = function() {
    if (this.shadowRoot) {
      this._$needsHydration = true;
      return this.shadowRoot;
    } else {
      return createRenderRoot.call(this);
    }
  };
  const update = Object.getPrototypeOf(LitElement.prototype).update;
  LitElement.prototype.update = function(changedProperties) {
    const value = this.render();
    update.call(this, changedProperties);
    if (this._$needsHydration) {
      this._$needsHydration = false;
      hydrate(value, this.renderRoot, this.renderOptions);
    } else {
      render(value, this.renderRoot, this.renderOptions);
    }
  };
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
//# sourceMappingURL=chunk-K3VJEWY6.js.map
